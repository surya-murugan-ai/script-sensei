[
  {
    "projectId": "75b9eca9-d2a5-41f7-a86d-27c238bcb802",
    "testId": "518535d0-daf0-4cf3-a843-d6bb949a1025",
    "userId": "e468b478-00f1-70bb-e7a0-b845d2b9acfc",
    "title": "TC001-health check api returns application status",
    "description": "Verify that the /api/health GET endpoint returns the application health status with status, timestamp, and uptime fields correctly.",
    "code": "import requests\nfrom datetime import datetime\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\n\ndef test_health_check_api_returns_application_status():\n    url = f\"{BASE_URL}/api/health\"\n    try:\n        response = requests.get(url, timeout=TIMEOUT)\n        response.raise_for_status()\n    except requests.RequestException as e:\n        assert False, f\"Request to {url} failed with exception: {e}\"\n\n    assert response.status_code == 200, f\"Expected status code 200, got {response.status_code}\"\n\n    json_data = response.json()\n    # Validate presence of keys\n    assert \"status\" in json_data, \"'status' key not in response\"\n    assert \"timestamp\" in json_data, \"'timestamp' key not in response\"\n    assert \"uptime\" in json_data, \"'uptime' key not in response\"\n\n    # Validate status value\n    assert isinstance(json_data[\"status\"], str), \"'status' should be a string\"\n    # Example value from PRD: \"healthy\"\n    assert json_data[\"status\"].lower() == \"healthy\", f\"Expected status 'healthy', got '{json_data['status']}'\"\n\n    # Validate timestamp is ISO 8601 date-time string parseable by datetime.fromisoformat\n    timestamp = json_data[\"timestamp\"]\n    try:\n        parsed_time = datetime.fromisoformat(timestamp.replace(\"Z\", \"+00:00\"))\n    except Exception as e:\n        assert False, f\"Timestamp '{timestamp}' is not a valid ISO 8601 date-time string: {e}\"\n\n    # Validate uptime is a number (int or float) and positive\n    uptime = json_data[\"uptime\"]\n    assert isinstance(uptime, (int, float)), f\"'uptime' should be a number, got {type(uptime)}\"\n    assert uptime >= 0, \"'uptime' should be non-negative\"\n\ntest_health_check_api_returns_application_status()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-24T10:10:27.564Z",
    "modified": "2025-10-24T10:10:50.891Z"
  },
  {
    "projectId": "75b9eca9-d2a5-41f7-a86d-27c238bcb802",
    "testId": "6c4468a3-c184-484f-8285-cd6cc7313aeb",
    "userId": "e468b478-00f1-70bb-e7a0-b845d2b9acfc",
    "title": "TC002-get all prescriptions returns prescription list",
    "description": "Test the /api/prescriptions GET endpoint to ensure it returns a list of all prescription records with id, processingStatus, and createdAt fields.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\n\ndef test_get_all_prescriptions_returns_prescription_list():\n    url = f\"{BASE_URL}/api/prescriptions\"\n    headers = {\n        \"Accept\": \"application/json\",\n    }\n    try:\n        response = requests.get(url, headers=headers, timeout=TIMEOUT)\n        response.raise_for_status()\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\n    assert response.status_code == 200, f\"Expected status code 200, got {response.status_code}\"\n\n    try:\n        prescriptions = response.json()\n    except ValueError:\n        assert False, \"Response is not valid JSON\"\n\n    assert isinstance(prescriptions, list), \"Response should be a list\"\n\n    for pres in prescriptions:\n        assert isinstance(pres, dict), \"Each prescription should be a dict\"\n        assert \"id\" in pres, \"Prescription missing 'id' field\"\n        assert isinstance(pres[\"id\"], str), \"'id' should be a string\"\n        assert \"processingStatus\" in pres, \"Prescription missing 'processingStatus' field\"\n        assert isinstance(pres[\"processingStatus\"], str), \"'processingStatus' should be a string\"\n        assert \"createdAt\" in pres, \"Prescription missing 'createdAt' field\"\n        assert isinstance(pres[\"createdAt\"], str), \"'createdAt' should be a string\"\n\ntest_get_all_prescriptions_returns_prescription_list()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 35, in <module>\n  File \"<string>\", line 32, in test_get_all_prescriptions_returns_prescription_list\nAssertionError: Prescription missing 'createdAt' field\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-24T10:10:27.570Z",
    "modified": "2025-10-24T10:11:06.515Z"
  },
  {
    "projectId": "75b9eca9-d2a5-41f7-a86d-27c238bcb802",
    "testId": "e00d305e-1a9a-4f74-8185-13f36cc6b63d",
    "userId": "e468b478-00f1-70bb-e7a0-b845d2b9acfc",
    "title": "TC003-upload prescription images accepts multiple files",
    "description": "Validate the /api/prescriptions/upload POST endpoint to accept multiple prescription image files, validate file types and sizes, and return uploaded prescription IDs.",
    "code": "import requests\nimport io\n\nBASE_URL = \"http://localhost:3000\"\nUPLOAD_ENDPOINT = f\"{BASE_URL}/api/prescriptions/upload\"\nDELETE_ENDPOINT_TEMPLATE = f\"{BASE_URL}/api/prescriptions/{{}}\"\n\n# Accepted MIME types for prescription images according to typical image upload standards\nACCEPTED_MIME_TYPES = [\n    \"image/jpeg\",\n    \"image/png\",\n    \"image/tiff\",\n    \"image/bmp\",\n    \"image/webp\"\n]\n\n# Generate dummy image binary data for test files (minimal valid JPEG header)\nDUMMY_JPEG = (\n    b\"\\xFF\\xD8\\xFF\"  # SOI marker\n    b\"\\xE0\\x00\\x10JFIF\\x00\\x01\\x01\\x00\\x00\\x01\\x00\\x01\\x00\\x00\"\n    b\"\\xFF\\xD9\"  # EOI marker\n)\n\nDUMMY_PNG = (\n    b\"\\x89PNG\\r\\n\\x1a\\n\\x00\\x00\\x00\\rIHDR\"\n    b\"\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x01\\x08\\x06\\x00\\x00\\x00\\x1f\"\n    b\"\\x15\\xc4\\x89\\x00\\x00\\x00\\nIDATx\\x9cc\\xf8\\x0f\\x00\\x01\\x01\"\n    b\"\\x01\\x00\\x18\\xdd\\x18\\xb5\\x00\\x00\\x00\\x00IEND\\xaeB`\\x82\"\n)\n\ndef test_tc003_upload_prescription_images_accepts_multiple_files():\n    # Prepare multiple files with various accepted types and sizes\n    \n    files = {\n        \"files\": [\n            (\"files\", (\"prescription1.jpg\", io.BytesIO(DUMMY_JPEG), \"image/jpeg\")),\n            (\"files\", (\"prescription2.png\", io.BytesIO(DUMMY_PNG), \"image/png\")),\n            (\"files\", (\"prescription3.jpg\", io.BytesIO(DUMMY_JPEG), \"image/jpeg\"))\n        ]\n    }\n    \n    prescription_ids = []\n    try:\n        response = requests.post(\n            UPLOAD_ENDPOINT,\n            files=[\n                (\"files\", (\"prescription1.jpg\", io.BytesIO(DUMMY_JPEG), \"image/jpeg\")),\n                (\"files\", (\"prescription2.png\", io.BytesIO(DUMMY_PNG), \"image/png\")),\n                (\"files\", (\"prescription3.jpg\", io.BytesIO(DUMMY_JPEG), \"image/jpeg\")),\n            ],\n            timeout=30\n        )\n        assert response.status_code == 200, f\"Expected status 200, got {response.status_code}\"\n        \n        resp_json = response.json()\n        assert \"message\" in resp_json, \"Response JSON missing 'message'\"\n        assert \"prescriptionIds\" in resp_json, \"Response JSON missing 'prescriptionIds'\"\n        assert isinstance(resp_json[\"prescriptionIds\"], list), \"'prescriptionIds' is not a list\"\n        assert len(resp_json[\"prescriptionIds\"]) == 3, f\"Expected 3 prescriptionIds, got {len(resp_json['prescriptionIds'])}\"\n        prescription_ids = resp_json[\"prescriptionIds\"]\n        for pid in prescription_ids:\n            assert isinstance(pid, str) and pid.strip() != \"\", f\"Invalid prescription ID returned: {pid}\"\n    finally:\n        # Cleanup: delete uploaded prescriptions to avoid DB pollution\n        for pid in prescription_ids:\n            try:\n                del_resp = requests.delete(DELETE_ENDPOINT_TEMPLATE.format(pid), timeout=30)\n                # We consider delete success if status code is 200 or 204 or 404 (already deleted)\n                assert del_resp.status_code in [200, 204, 404], f\"Failed to delete prescription ID {pid}, status: {del_resp.status_code}\"\n            except Exception:\n                pass\n\n\ntest_tc003_upload_prescription_images_accepts_multiple_files()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 74, in <module>\n  File \"<string>\", line 53, in test_tc003_upload_prescription_images_accepts_multiple_files\nAssertionError: Expected status 200, got 500\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-24T10:10:27.575Z",
    "modified": "2025-10-24T10:11:05.832Z"
  },
  {
    "projectId": "75b9eca9-d2a5-41f7-a86d-27c238bcb802",
    "testId": "7ac4cb3f-1864-42c1-a833-ae90dc173d3f",
    "userId": "e468b478-00f1-70bb-e7a0-b845d2b9acfc",
    "title": "TC004-get prescription by id returns prescription details",
    "description": "Test the /api/prescriptions/{id} GET endpoint to retrieve a specific prescription by ID including processingStatus and extractedData.",
    "code": "import requests\nimport time\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\n\ndef test_get_prescription_by_id_returns_prescription_details():\n    # Prepare: Upload a sample prescription image to create a prescription record\n    upload_url = f\"{BASE_URL}/api/prescriptions/upload\"\n    files = {\n        \"files\": (\"test_prescription.jpg\", b\"fake_image_data_for_test_purpose\", \"image/jpeg\")\n    }\n    prescription_id = None\n    try:\n        # Upload prescription image\n        upload_response = requests.post(upload_url, files=files, timeout=TIMEOUT)\n        assert upload_response.status_code == 200, f\"Upload failed with status {upload_response.status_code}\"\n        upload_json = upload_response.json()\n        assert \"prescriptionIds\" in upload_json, \"No prescriptionIds in upload response\"\n        prescription_ids = upload_json[\"prescriptionIds\"]\n        assert isinstance(prescription_ids, list) and len(prescription_ids) > 0, \"Uploaded prescriptionIds list is empty\"\n        prescription_id = prescription_ids[0]\n\n        # Since the system processes AI extraction in background, wait and poll for processing completion and data presence\n        get_prescription_url = f\"{BASE_URL}/api/prescriptions/{prescription_id}\"\n        max_retries = 10\n        retry_delay = 3  # seconds\n        prescription_data = None\n        for _ in range(max_retries):\n            get_response = requests.get(get_prescription_url, timeout=TIMEOUT)\n            if get_response.status_code == 200:\n                data = get_response.json()\n                # Validate presence of required fields\n                if data.get(\"processingStatus\") in (\"completed\", \"failed\") and \"extractedData\" in data:\n                    prescription_data = data\n                    break\n            time.sleep(retry_delay)\n        assert prescription_data is not None, \"Prescription data with processingStatus and extractedData not available after retries\"\n\n        # Assertions on the prescription data\n        assert prescription_data[\"id\"] == prescription_id, \"Prescription ID mismatch\"\n        assert isinstance(prescription_data[\"processingStatus\"], str), \"processingStatus is not a string\"\n        assert isinstance(prescription_data[\"extractedData\"], dict), \"extractedData is not an object\"\n\n    finally:\n        # Cleanup: Delete the created prescription to avoid pollution\n        if prescription_id:\n            delete_url = f\"{BASE_URL}/api/prescriptions/{prescription_id}\"\n            try:\n                requests.delete(delete_url, timeout=TIMEOUT)\n            except Exception:\n                pass\n\ntest_get_prescription_by_id_returns_prescription_details()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 54, in <module>\n  File \"<string>\", line 17, in test_get_prescription_by_id_returns_prescription_details\nAssertionError: Upload failed with status 500\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-24T10:10:27.580Z",
    "modified": "2025-10-24T10:11:01.220Z"
  },
  {
    "projectId": "75b9eca9-d2a5-41f7-a86d-27c238bcb802",
    "testId": "3b4c3e79-7ee6-46ea-8e4e-9954c1ab9545",
    "userId": "e468b478-00f1-70bb-e7a0-b845d2b9acfc",
    "title": "TC005-delete prescription supports force delete option",
    "description": "Verify the /api/prescriptions/{id} DELETE endpoint deletes a prescription record and supports an optional force delete query parameter.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\n\ndef test_delete_prescription_supports_force_delete_option():\n    # Step 1: Upload a prescription image to create a prescription resource to delete\n    upload_url = f\"{BASE_URL}/api/prescriptions/upload\"\n    # Using a small dummy image file from binary data for upload\n    dummy_image_content = (\n        b\"\\x89PNG\\r\\n\\x1a\\n\\x00\\x00\\x00\\rIHDR\\x00\\x00\\x00\\x01\\x00\\x00\\x00\\x01\"\n        b\"\\x08\\x02\\x00\\x00\\x00\\x90wS\\xde\\x00\\x00\\x00\\nIDATx\\x9cc`\\x00\\x00\\x00\\x02\"\n        b\"\\x00\\x01\\xe2!\\xbc3\\x00\\x00\\x00\\x00IEND\\xaeB`\\x82\"\n    )\n    files = [(\"files\", (\"test.png\", dummy_image_content, \"image/png\"))]\n    try:\n        upload_resp = requests.post(upload_url, files=files, timeout=TIMEOUT)\n        assert upload_resp.status_code == 200, f\"Upload failed: {upload_resp.text}\"\n        upload_data = upload_resp.json()\n        assert \"prescriptionIds\" in upload_data and len(upload_data[\"prescriptionIds\"]) > 0\n        prescription_id = upload_data[\"prescriptionIds\"][0]\n\n        delete_url = f\"{BASE_URL}/api/prescriptions/{prescription_id}\"\n\n        # Step 2: Verify the prescription exists before deletion (optional sanity check)\n        get_resp = requests.get(delete_url, timeout=TIMEOUT)\n        assert get_resp.status_code == 200, f\"Prescription not found before deletion: {get_resp.text}\"\n\n        # Step 3: Delete the prescription without force parameter\n        del_resp = requests.delete(delete_url, timeout=TIMEOUT)\n        assert del_resp.status_code == 200, f\"Deletion without force failed: {del_resp.text}\"\n\n        # Step 4: After deletion, verify the prescription is not retrievable (expect 404 or similar)\n        get_after_del_resp = requests.get(delete_url, timeout=TIMEOUT)\n        assert get_after_del_resp.status_code in (404, 410), \"Prescription still accessible after deletion\"\n\n        # Step 5: Re-upload the prescription to test force delete\n        reupload_resp = requests.post(upload_url, files=files, timeout=TIMEOUT)\n        assert reupload_resp.status_code == 200, f\"Re-upload failed: {reupload_resp.text}\"\n        reupload_data = reupload_resp.json()\n        prescription_id_force = reupload_data[\"prescriptionIds\"][0]\n\n        # Step 6: Delete with force=true query parameter\n        force_delete_url = f\"{BASE_URL}/api/prescriptions/{prescription_id_force}?force=true\"\n        force_del_resp = requests.delete(force_delete_url, timeout=TIMEOUT)\n        assert force_del_resp.status_code == 200, f\"Force deletion failed: {force_del_resp.text}\"\n\n        # Step 7: Verify prescription is deleted after force delete\n        get_after_force_del_resp = requests.get(f\"{BASE_URL}/api/prescriptions/{prescription_id_force}\", timeout=TIMEOUT)\n        assert get_after_force_del_resp.status_code in (404, 410), \"Prescription still accessible after force deletion\"\n\n    finally:\n        # Cleanup attempts just in case the prescription still exists\n        # Non-forced delete\n        try:\n            requests.delete(f\"{BASE_URL}/api/prescriptions/{prescription_id}\", timeout=TIMEOUT)\n        except:\n            pass\n        try:\n            requests.delete(f\"{BASE_URL}/api/prescriptions/{prescription_id_force}\", timeout=TIMEOUT)\n        except:\n            pass\n\ntest_delete_prescription_supports_force_delete_option()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 64, in <module>\n  File \"<string>\", line 18, in test_delete_prescription_supports_force_delete_option\nAssertionError: Upload failed: {\"error\":\"Failed to upload files\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-24T10:10:27.585Z",
    "modified": "2025-10-24T10:11:27.113Z"
  },
  {
    "projectId": "75b9eca9-d2a5-41f7-a86d-27c238bcb802",
    "testId": "e703b0ea-9382-4a8c-8317-2d1193d77519",
    "userId": "e468b478-00f1-70bb-e7a0-b845d2b9acfc",
    "title": "TC006-process prescription with ai returns extracted data",
    "description": "Test the /api/prescriptions/{id}/process POST endpoint to process a prescription image using AI models and return extracted data in the response.",
    "code": "import requests\nimport io\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\n\ndef test_process_prescription_with_ai_returns_extracted_data():\n    session = requests.Session()\n    prescription_id = None\n    try:\n        # Step 1: Upload a prescription image to get a prescription ID\n        upload_url = f\"{BASE_URL}/api/prescriptions/upload\"\n        # Use a small valid sample prescription image content (PNG header with minimal data)\n        sample_image_content = (\n            b\"\\x89PNG\\r\\n\\x1a\\n\\x00\\x00\\x00\\rIHDR\\x00\\x00\\x00\\x01\"\n            b\"\\x00\\x00\\x00\\x01\\x08\\x06\\x00\\x00\\x00\\x1f\\x15\\xc4\\x89\"\n            b\"\\x00\\x00\\x00\\nIDATx\\xdacd\\xf8\\x0f\\x00\\x01\\x01\\x01\\x00\"\n            b\"\\x18\\xdd\\x8d\\xe2\\x00\\x00\\x00\\x00IEND\\xaeB`\\x82\"\n        )\n        files = {'files': ('prescription.png', io.BytesIO(sample_image_content), 'image/png')}\n        upload_resp = session.post(upload_url, files=files, timeout=TIMEOUT)\n        assert upload_resp.status_code == 200, f\"Upload failed with status {upload_resp.status_code}\"\n        upload_json = upload_resp.json()\n        assert \"prescriptionIds\" in upload_json and isinstance(upload_json[\"prescriptionIds\"], list)\n        assert len(upload_json[\"prescriptionIds\"]) > 0\n        prescription_id = upload_json[\"prescriptionIds\"][0]\n\n        # Step 2: Process the uploaded prescription using AI\n        process_url = f\"{BASE_URL}/api/prescriptions/{prescription_id}/process\"\n        # The API expects multipart/form-data with a file field\n        files = {'file': ('prescription.png', io.BytesIO(sample_image_content), 'image/png')}\n        process_resp = session.post(process_url, files=files, timeout=TIMEOUT)\n        assert process_resp.status_code == 200, f\"Processing failed with status {process_resp.status_code}\"\n        process_json = process_resp.json()\n        assert \"message\" in process_json and isinstance(process_json[\"message\"], str)\n        assert process_json[\"message\"].lower() in (\"processing completed\", \"success\", \"processed\")\n        assert \"extractedData\" in process_json and isinstance(process_json[\"extractedData\"], dict)\n        extracted_data = process_json[\"extractedData\"]\n        # Basic validation of extracted data structure (must have patient, medication, investigations or doctor entries)\n        keys = extracted_data.keys()\n        assert any(k in keys for k in (\"patient\", \"medication\", \"investigations\", \"doctor\")), \\\n            \"Extracted data missing expected keys\"\n\n        # Step 3: Validate that status is updated in DB by retrieving prescription details\n        get_url = f\"{BASE_URL}/api/prescriptions/{prescription_id}\"\n        get_resp = session.get(get_url, timeout=TIMEOUT)\n        assert get_resp.status_code == 200, f\"Get prescription failed with status {get_resp.status_code}\"\n        get_json = get_resp.json()\n        # Verify processingStatus is either completed or similar\n        assert \"processingStatus\" in get_json and isinstance(get_json[\"processingStatus\"], str)\n        assert get_json[\"processingStatus\"].lower() in (\"completed\", \"processed\", \"done\")\n        # Check extractedData persistence matches response extractedData keys at least\n        assert \"extractedData\" in get_json and isinstance(get_json[\"extractedData\"], dict)\n        # Keys presence check between response and get data\n        get_keys = get_json[\"extractedData\"].keys()\n        assert set(keys).issubset(set(get_keys)), \"Persisted extractedData keys mismatch\"\n\n    finally:\n        # Cleanup: Delete the prescription created during the test\n        if prescription_id:\n            del_url = f\"{BASE_URL}/api/prescriptions/{prescription_id}\"\n            session.delete(del_url, timeout=TIMEOUT)\n\ntest_process_prescription_with_ai_returns_extracted_data()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 64, in <module>\n  File \"<string>\", line 22, in test_process_prescription_with_ai_returns_extracted_data\nAssertionError: Upload failed with status 500\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-24T10:10:27.592Z",
    "modified": "2025-10-24T10:11:02.660Z"
  },
  {
    "projectId": "75b9eca9-d2a5-41f7-a86d-27c238bcb802",
    "testId": "43d8eed2-4e50-48bb-affe-a0f5f687ad10",
    "userId": "e468b478-00f1-70bb-e7a0-b845d2b9acfc",
    "title": "TC007-get all extraction results returns ai extraction data",
    "description": "Validate the /api/extraction-results GET endpoint returns a list of AI extraction results including id, model, and extractedData fields.",
    "code": "import requests\nimport time\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\n\ndef test_get_all_extraction_results_returns_ai_extraction_data():\n    # First, ensure there is at least one extraction result by uploading a prescription,\n    # processing it with AI to generate extraction results.\n    upload_url = f\"{BASE_URL}/api/prescriptions/upload\"\n    process_url_template = f\"{BASE_URL}/api/prescriptions/{{id}}/process\"\n    extraction_results_url = f\"{BASE_URL}/api/extraction-results\"\n    delete_url_template = f\"{BASE_URL}/api/prescriptions/{{id}}\"\n\n    headers = {}\n    files = [\n        (\"files\", (\n            \"test_prescription.jpg\",\n            b\"\\xFF\\xD8\\xFF\\xE0\" + b\"\\x00\" * 1024,  # Minimal JPEG binary content with padding\n            \"image/jpeg\"\n        ))\n    ]\n    prescription_id = None\n    try:\n        # Step 1: Upload a prescription image to create a prescription resource\n        upload_response = requests.post(\n            upload_url,\n            files=files,\n            timeout=TIMEOUT,\n            headers=headers\n        )\n        assert upload_response.status_code == 200, f\"Upload failed: {upload_response.text}\"\n        upload_data = upload_response.json()\n        assert \"prescriptionIds\" in upload_data and isinstance(upload_data[\"prescriptionIds\"], list)\n        assert len(upload_data[\"prescriptionIds\"]) > 0\n        prescription_id = upload_data[\"prescriptionIds\"][0]\n\n        # Step 2: Process the uploaded prescription with AI to generate extraction results\n        with open(\"test_prescription.jpg\", \"wb\") as f:\n            f.write(files[0][1][1])  # Write temp file for processing\n\n        with open(\"test_prescription.jpg\", \"rb\") as f:\n            files_process = {\"file\": (\"test_prescription.jpg\", f, \"image/jpeg\")}\n            process_response = requests.post(\n                process_url_template.format(id=prescription_id),\n                files=files_process,\n                timeout=TIMEOUT,\n                headers=headers\n            )\n        assert process_response.status_code == 200, f\"AI processing failed: {process_response.text}\"\n        process_data = process_response.json()\n        assert \"extractedData\" in process_data\n\n        # Allow some time for extraction results to be persisted if async\n        time.sleep(1.5)\n\n        # Step 3: Call the extraction-results GET endpoint\n        extraction_response = requests.get(extraction_results_url, timeout=TIMEOUT, headers=headers)\n        assert extraction_response.status_code == 200, f\"Failed to get extraction results: {extraction_response.text}\"\n        extraction_results = extraction_response.json()\n        assert isinstance(extraction_results, list), \"Extraction results is not a list\"\n        assert len(extraction_results) > 0, \"Extraction results list is empty\"\n\n        # Validate each extraction result has id, model, and extractedData fields\n        for result in extraction_results:\n            assert isinstance(result, dict), \"Extraction result item is not an object\"\n            assert \"id\" in result and isinstance(result[\"id\"], str), \"Missing or invalid 'id' in extraction result\"\n            assert \"model\" in result and isinstance(result[\"model\"], str), \"Missing or invalid 'model' in extraction result\"\n            assert \"extractedData\" in result and isinstance(result[\"extractedData\"], dict), \"Missing or invalid 'extractedData' in extraction result\"\n\n    finally:\n        if prescription_id:\n            # Cleanup: delete the uploaded prescription\n            try:\n                del_response = requests.delete(delete_url_template.format(id=prescription_id), timeout=TIMEOUT)\n                assert del_response.status_code == 200, f\"Failed to delete prescription {prescription_id}\"\n            except Exception:\n                pass\n\ntest_get_all_extraction_results_returns_ai_extraction_data()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 80, in <module>\n  File \"<string>\", line 32, in test_get_all_extraction_results_returns_ai_extraction_data\nAssertionError: Upload failed: {\"error\":\"Failed to upload files\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-24T10:10:27.597Z",
    "modified": "2025-10-24T10:11:28.734Z"
  },
  {
    "projectId": "75b9eca9-d2a5-41f7-a86d-27c238bcb802",
    "testId": "df6aebca-9dc2-4b92-9ee5-8d38a50d93f5",
    "userId": "e468b478-00f1-70bb-e7a0-b845d2b9acfc",
    "title": "TC008-get ai configurations returns configuration list",
    "description": "Test the /api/configs GET endpoint to retrieve all AI model configurations including selectedModels and isDefault flags.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\n\ndef test_get_ai_configurations_returns_configuration_list():\n    url = f\"{BASE_URL}/api/configs\"\n    headers = {\n        \"Accept\": \"application/json\"\n    }\n    try:\n        response = requests.get(url, headers=headers, timeout=TIMEOUT)\n        response.raise_for_status()\n    except requests.RequestException as e:\n        assert False, f\"Request to {url} failed: {e}\"\n\n    assert response.status_code == 200, f\"Expected status 200, got {response.status_code}\"\n    try:\n        configs = response.json()\n    except ValueError:\n        assert False, \"Response is not valid JSON\"\n\n    assert isinstance(configs, list), \"Response JSON is not a list\"\n\n    for config in configs:\n        assert isinstance(config, dict), \"Each configuration should be a dictionary\"\n        assert \"id\" in config and isinstance(config[\"id\"], str), \"Config missing string 'id'\"\n        assert \"selectedModels\" in config and isinstance(config[\"selectedModels\"], list), \"Config missing list 'selectedModels'\"\n        for model in config[\"selectedModels\"]:\n            assert isinstance(model, str), \"'selectedModels' items must be strings\"\n        assert \"isDefault\" in config and isinstance(config[\"isDefault\"], bool), \"Config missing boolean 'isDefault'\"\n\ntest_get_ai_configurations_returns_configuration_list()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-24T10:10:27.602Z",
    "modified": "2025-10-24T10:11:02.635Z"
  },
  {
    "projectId": "75b9eca9-d2a5-41f7-a86d-27c238bcb802",
    "testId": "52ebd90f-f631-44c4-82e3-95e3fd3c98a6",
    "userId": "e468b478-00f1-70bb-e7a0-b845d2b9acfc",
    "title": "TC009-create ai configuration stores new configuration",
    "description": "Verify the /api/configs POST endpoint creates a new AI model configuration with selectedModels and isDefault properties and returns success status.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\n\ndef test_create_ai_configuration_stores_new_configuration():\n    url = f\"{BASE_URL}/api/configs\"\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n    # Prepare payload with typical selectedModels and isDefault flag\n    payload = {\n        \"selectedModels\": [\"OpenAI GPT-4V\", \"Anthropic Claude\", \"Google Gemini\"],\n        \"isDefault\": False\n    }\n\n    response = requests.post(url, json=payload, headers=headers, timeout=TIMEOUT)\n    assert response.status_code == 201, f\"Expected 201, got {response.status_code}\"\n    # The response may not have a body according to PRD, but if it does, validate presence of ID or similar\n    try:\n        resp_json = response.json()\n        # If response returns created config id or object, validate fields\n        if isinstance(resp_json, dict):\n            # If id returned, check it is string and non-empty\n            if \"id\" in resp_json:\n                assert isinstance(resp_json[\"id\"], str) and resp_json[\"id\"], \"Missing or invalid id in response\"\n            # Validate selectedModels match\n            if \"selectedModels\" in resp_json:\n                assert set(resp_json[\"selectedModels\"]) == set(payload[\"selectedModels\"]), \\\n                    \"Mismatch in selectedModels in response\"\n            if \"isDefault\" in resp_json:\n                assert resp_json[\"isDefault\"] == payload[\"isDefault\"], \"Mismatch in isDefault flag in response\"\n    except Exception:\n        # If no JSON or no body, that's acceptable as per PRD\n        pass\n\ntest_create_ai_configuration_stores_new_configuration()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 38, in <module>\n  File \"<string>\", line 19, in test_create_ai_configuration_stores_new_configuration\nAssertionError: Expected 201, got 400\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-24T10:10:27.608Z",
    "modified": "2025-10-24T10:11:09.203Z"
  },
  {
    "projectId": "75b9eca9-d2a5-41f7-a86d-27c238bcb802",
    "testId": "151720bc-6648-4455-ad47-93bdeda6162a",
    "userId": "e468b478-00f1-70bb-e7a0-b845d2b9acfc",
    "title": "TC010-export prescription data as csv file",
    "description": "Test the /api/export/csv GET endpoint to export prescription data in CSV format based on optional prescriptionId or prescriptionIds query parameters and verify the CSV file download.",
    "code": "import requests\nimport time\n\nBASE_URL = \"http://localhost:3000\"\nTIMEOUT = 30\n\ndef test_export_prescription_data_as_csv():\n    headers = {}\n    prescription_ids = []\n\n    # Step 1: Upload prescription image to create a prescription resource for export testing\n    # Using a sample image file content for upload; replace 'sample_prescription.jpg' with valid path if needed\n    files = [\n        ('files', (\n            'sample_prescription.jpg',\n            b'\\xFF\\xD8\\xFF\\xE0' + b'\\x00' * 1000,  # Minimal JPEG header with padding bytes\n            'image/jpeg'\n        ))\n    ]\n\n    try:\n        upload_resp = requests.post(f\"{BASE_URL}/api/prescriptions/upload\", files=files, timeout=TIMEOUT)\n        assert upload_resp.status_code == 200, f\"Upload failed with status {upload_resp.status_code}\"\n        upload_json = upload_resp.json()\n        assert \"prescriptionIds\" in upload_json, \"Response missing 'prescriptionIds'\"\n        prescription_ids = upload_json[\"prescriptionIds\"]\n        assert isinstance(prescription_ids, list) and len(prescription_ids) > 0, \"No prescription IDs returned\"\n\n        # Wait for processing to complete by polling prescription status until completed or timeout\n        max_wait = 60\n        interval = 5\n        completed = False\n        for _ in range(max_wait // interval):\n            all_completed = True\n            for pid in prescription_ids:\n                resp = requests.get(f\"{BASE_URL}/api/prescriptions/{pid}\", timeout=TIMEOUT)\n                if resp.status_code != 200:\n                    all_completed = False\n                    break\n                dat = resp.json()\n                status = dat.get(\"processingStatus\")\n                if status != \"completed\":\n                    all_completed = False\n                    break\n            if all_completed:\n                completed = True\n                break\n            time.sleep(interval)\n\n        assert completed, \"Prescription processing did not complete in time\"\n\n        # Step 2: Test export CSV with single prescriptionId query parameter\n        query_params_single = {\"prescriptionId\": prescription_ids[0]}\n        export_single_resp = requests.get(f\"{BASE_URL}/api/export/csv\", params=query_params_single, timeout=TIMEOUT)\n        assert export_single_resp.status_code == 200, f\"Export single CSV failed with status {export_single_resp.status_code}\"\n        content_type_single = export_single_resp.headers.get(\"Content-Type\", \"\")\n        assert \"text/csv\" in content_type_single.lower(), f\"Content-Type is not CSV but {content_type_single}\"\n        csv_content_single = export_single_resp.text\n        assert csv_content_single.strip() != \"\", \"CSV content for single prescription is empty\"\n        # Basic CSV format check: presence of newline and commas\n        assert \",\" in csv_content_single, \"CSV content does not contain commas\"\n        assert \"\\n\" in csv_content_single, \"CSV content does not contain newlines\"\n\n        # Step 3: Test export CSV with multiple prescriptionIds (comma-separated)\n        pres_ids_str = \",\".join(prescription_ids)\n        query_params_multi = {\"prescriptionIds\": pres_ids_str}\n        export_multi_resp = requests.get(f\"{BASE_URL}/api/export/csv\", params=query_params_multi, timeout=TIMEOUT)\n        assert export_multi_resp.status_code == 200, f\"Export multi CSV failed with status {export_multi_resp.status_code}\"\n        content_type_multi = export_multi_resp.headers.get(\"Content-Type\", \"\")\n        assert \"text/csv\" in content_type_multi.lower(), f\"Content-Type is not CSV but {content_type_multi}\"\n        csv_content_multi = export_multi_resp.text\n        assert csv_content_multi.strip() != \"\", \"CSV content for multiple prescriptions is empty\"\n        # Check more than one line since multiple prescriptions\n        lines = csv_content_multi.strip().splitlines()\n        assert len(lines) > 1, \"CSV content for multiple prescriptions should have multiple lines\"\n        assert \",\" in csv_content_multi, \"CSV content does not contain commas\"\n\n        # Step 4: Test export CSV with no query params to export all (should succeed but content depends)\n        export_all_resp = requests.get(f\"{BASE_URL}/api/export/csv\", timeout=TIMEOUT)\n        assert export_all_resp.status_code == 200, f\"Export all CSV failed with status {export_all_resp.status_code}\"\n        content_type_all = export_all_resp.headers.get(\"Content-Type\", \"\")\n        assert \"text/csv\" in content_type_all.lower(), f\"Content-Type is not CSV but {content_type_all}\"\n        csv_content_all = export_all_resp.text\n        assert csv_content_all.strip() != \"\", \"CSV content for all prescriptions is empty\"\n        assert \",\" in csv_content_all, \"CSV content does not contain commas\"\n        assert \"\\n\" in csv_content_all, \"CSV content does not contain newlines\"\n\n    finally:\n        # Cleanup: delete the created prescriptions\n        for pid in prescription_ids:\n            try:\n                del_resp = requests.delete(f\"{BASE_URL}/api/prescriptions/{pid}\", timeout=TIMEOUT)\n                # Accept 200 or 204 as success for deletion\n                assert del_resp.status_code in (200, 204), f\"Failed to delete prescription {pid}, status {del_resp.status_code}\"\n            except Exception:\n                pass\n\ntest_export_prescription_data_as_csv()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 98, in <module>\n  File \"<string>\", line 23, in test_export_prescription_data_as_csv\nAssertionError: Upload failed with status 500\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-24T10:10:27.614Z",
    "modified": "2025-10-24T10:11:31.837Z"
  }
]
