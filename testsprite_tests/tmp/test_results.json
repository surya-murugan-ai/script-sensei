[
  {
    "projectId": "1410c8a3-78ca-4402-b7a2-8a693caa587a",
    "testId": "0df655bd-63a1-45d3-86bd-7881446c70c6",
    "userId": "e468b478-00f1-70bb-e7a0-b845d2b9acfc",
    "title": "TC001-health check endpoint returns application status uptime",
    "description": "Verify that the GET /api/health endpoint returns a 200 status with a JSON object containing the application status, current timestamp, and uptime in seconds.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:5000\"\nTIMEOUT = 30\n\ndef test_health_check_endpoint_returns_application_status_uptime():\n    url = f\"{BASE_URL}/api/health\"\n    try:\n        response = requests.get(url, timeout=TIMEOUT)\n        response.raise_for_status()\n    except requests.RequestException as e:\n        assert False, f\"Request to {url} failed: {e}\"\n    assert response.status_code == 200, f\"Expected status code 200, got {response.status_code}\"\n\n    try:\n        data = response.json()\n    except ValueError:\n        assert False, \"Response is not valid JSON\"\n\n    assert isinstance(data, dict), \"Response JSON is not an object\"\n    assert \"status\" in data, \"'status' field missing from response\"\n    assert isinstance(data[\"status\"], str), \"'status' is not a string\"\n    assert \"timestamp\" in data, \"'timestamp' field missing from response\"\n    assert isinstance(data[\"timestamp\"], str), \"'timestamp' is not a string\"\n    assert \"uptime\" in data, \"'uptime' field missing from response\"\n    assert isinstance(data[\"uptime\"], (int, float)), \"'uptime' is not a number\"\n    assert data[\"uptime\"] >= 0, \"'uptime' should be non-negative\"\n\ntest_health_check_endpoint_returns_application_status_uptime()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-24T10:29:43.390Z",
    "modified": "2025-10-24T10:30:23.194Z"
  },
  {
    "projectId": "1410c8a3-78ca-4402-b7a2-8a693caa587a",
    "testId": "4dce72e0-8a10-4558-adb7-11d049c848ed",
    "userId": "e468b478-00f1-70bb-e7a0-b845d2b9acfc",
    "title": "TC002-upload prescription files with validation and unique identification",
    "description": "Test the POST /api/prescriptions/upload endpoint to ensure it accepts multiple prescription image files, validates file types and sizes, optimizes images, assigns unique identifiers, and returns a success message with uploaded prescription details.",
    "code": "import requests\nimport io\n\nBASE_URL = \"http://localhost:5000\"\nUPLOAD_ENDPOINT = f\"{BASE_URL}/api/prescriptions/upload\"\nDELETE_ENDPOINT_TEMPLATE = f\"{BASE_URL}/api/prescriptions/{{}}\"\nTIMEOUT = 30\n\n# Prepare sample prescription images in memory (simulate files)\ndef create_sample_image_file(filename: str, content=b\"fake-image-content\", content_type=\"image/jpeg\"):\n    return (filename, io.BytesIO(content), content_type)\n\ndef test_upload_prescription_files_with_validation_and_unique_identification():\n    # Prepare multiple files with allowed image types\n    files = [\n        create_sample_image_file(\"prescription1.jpg\"),\n        create_sample_image_file(\"prescription2.png\", content_type=\"image/png\"),\n    ]\n\n    multipart_files = [(\"files\", file_tuple) for file_tuple in files]\n\n    uploaded_prescriptions = []\n\n    try:\n        response = requests.post(\n            UPLOAD_ENDPOINT,\n            files=multipart_files,\n            timeout=TIMEOUT,\n        )\n        # Validate response status code\n        assert response.status_code == 200, f\"Expected status 200, got {response.status_code} - {response.text}\"\n        resp_json = response.json()\n        # Validate presence of success message and prescriptions array\n        assert \"message\" in resp_json, \"No success message in response\"\n        assert isinstance(resp_json.get(\"prescriptions\"), list), \"Prescriptions list missing or not a list\"\n        assert len(resp_json[\"prescriptions\"]) == len(files), \"Uploaded prescriptions count mismatch with files sent\"\n        uploaded_prescriptions = resp_json[\"prescriptions\"]\n        for p in uploaded_prescriptions:\n            # Each prescription item validations\n            assert \"id\" in p and isinstance(p[\"id\"], str) and p[\"id\"], \"Missing or invalid id\"\n            assert \"fileName\" in p and isinstance(p[\"fileName\"], str) and p[\"fileName\"], \"Missing or invalid fileName\"\n            assert \"fileSize\" in p and p[\"fileSize\"], \"Missing fileSize\"\n            assert \"createdAt\" in p and p[\"createdAt\"], \"Missing createdAt field\"\n            # Basic check to prevent server 500 due to validation problems\n            # Ensure no 500 happened internally by absence of error keys\n            assert \"processingStatus\" in p, \"Missing processingStatus\"\n\n    finally:\n        # Cleanup: delete uploaded prescriptions if created\n        for pres in uploaded_prescriptions:\n            pid = pres.get(\"id\")\n            if pid:\n                try:\n                    del_resp = requests.delete(\n                        DELETE_ENDPOINT_TEMPLATE.format(pid), timeout=TIMEOUT\n                    )\n                    assert del_resp.status_code == 200 or del_resp.status_code == 404, \\\n                        f\"Unexpected delete status {del_resp.status_code} for prescription ID {pid}\"\n                except Exception:\n                    pass\n\ntest_upload_prescription_files_with_validation_and_unique_identification()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 62, in <module>\n  File \"<string>\", line 31, in test_upload_prescription_files_with_validation_and_unique_identification\nAssertionError: Expected status 200, got 400 - {\"error\":\"No files could be processed\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-24T10:29:43.396Z",
    "modified": "2025-10-24T10:31:06.210Z"
  },
  {
    "projectId": "1410c8a3-78ca-4402-b7a2-8a693caa587a",
    "testId": "5f652667-8525-4d7e-9d4e-9ca7741c791c",
    "userId": "e468b478-00f1-70bb-e7a0-b845d2b9acfc",
    "title": "TC003-retrieve all prescriptions with correct data structure",
    "description": "Verify that the GET /api/prescriptions endpoint returns a 200 status with a list of prescriptions, each containing id, fileName, fileSize, uploadedAt, createdAt, processingStatus, extractedData, and imageData fields.",
    "code": "import requests\nimport json\n\nBASE_URL = \"http://localhost:5000\"\nTIMEOUT = 30\nHEADERS = {\n    \"Accept\": \"application/json\"\n}\n\ndef test_retrieve_all_prescriptions_with_correct_data_structure():\n    try:\n        response = requests.get(f\"{BASE_URL}/api/prescriptions\", headers=HEADERS, timeout=TIMEOUT)\n        response.raise_for_status()\n    except requests.RequestException as e:\n        assert False, f\"Request to get prescriptions failed: {e}\"\n\n    assert response.status_code == 200, f\"Expected status code 200, got {response.status_code}\"\n\n    try:\n        prescriptions = response.json()\n    except json.JSONDecodeError:\n        assert False, \"Response is not valid JSON\"\n\n    assert isinstance(prescriptions, list), f\"Expected a list of prescriptions, got {type(prescriptions)}\"\n\n    required_fields = {\"id\", \"fileName\", \"fileSize\", \"uploadedAt\", \"createdAt\", \"processingStatus\", \"extractedData\", \"imageData\"}\n    for idx, prescription in enumerate(prescriptions):\n        assert isinstance(prescription, dict), f\"Prescription at index {idx} is not an object\"\n        keys = set(prescription.keys())\n        missing = required_fields - keys\n        assert not missing, f\"Prescription at index {idx} is missing fields: {missing}\"\n\n        # Additional type checks for key fields\n        assert isinstance(prescription[\"id\"], str), f\"Prescription id at index {idx} is not a string\"\n        assert isinstance(prescription[\"fileName\"], str), f\"fileName at index {idx} is not a string\"\n        assert isinstance(prescription[\"fileSize\"], str), f\"fileSize at index {idx} is not a string\"\n        assert isinstance(prescription[\"uploadedAt\"], str), f\"uploadedAt at index {idx} is not a string\"\n        assert isinstance(prescription[\"createdAt\"], str), f\"createdAt at index {idx} is not a string\"\n        assert isinstance(prescription[\"processingStatus\"], str), f\"processingStatus at index {idx} is not a string\"\n        assert isinstance(prescription[\"extractedData\"], dict), f\"extractedData at index {idx} is not an object\"\n        assert isinstance(prescription[\"imageData\"], str), f\"imageData at index {idx} is not a string\"\n\n\ntest_retrieve_all_prescriptions_with_correct_data_structure()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-24T10:29:43.404Z",
    "modified": "2025-10-24T10:30:27.640Z"
  },
  {
    "projectId": "1410c8a3-78ca-4402-b7a2-8a693caa587a",
    "testId": "d44b538d-77ee-42f6-b73b-88c41e4c16db",
    "userId": "e468b478-00f1-70bb-e7a0-b845d2b9acfc",
    "title": "TC004-retrieve prescription by id with extraction results",
    "description": "Test the GET /api/prescriptions/{id} endpoint to return the prescription details including extraction results for a valid id, and return 404 for an invalid or non-existent id.",
    "code": "import requests\nimport io\n\nBASE_URL = \"http://localhost:5000\"\nTIMEOUT = 30\n\ndef test_retrieve_prescription_by_id_with_extraction_results():\n    # Step 1: Upload a prescription file to create resource for testing\n    upload_url = f\"{BASE_URL}/api/prescriptions/upload\"\n    # Prepare a small dummy image byte content for upload\n    dummy_image_content = (\n        b\"\\x89PNG\\r\\n\\x1a\\n\\x00\\x00\\x00\\rIHDR\\x00\\x00\\x00\\x01\"\n        b\"\\x00\\x00\\x00\\x01\\x08\\x02\\x00\\x00\\x00\\x90wS\\xde\\x00\"\n        b\"\\x00\\x00\\nIDATx\\xdacd\\xf8\\x0f\\x00\\x01\\x01\\x01\\x00\"\n        b\"\\x18\\xdd\\x03\\xc6\\x00\\x00\\x00\\x00IEND\\xaeB`\\x82\"\n    )\n    files = [\n        ('files[]', ('test_prescription.png', io.BytesIO(dummy_image_content), 'image/png'))\n    ]\n\n    prescription_id = None\n    config_id = None\n    try:\n        # Upload prescription file\n        response = requests.post(upload_url, files=files, timeout=TIMEOUT)\n        assert response.status_code == 200, f\"Upload failed with status {response.status_code} and text {response.text}\"\n        json_resp = response.json()\n        assert \"prescriptions\" in json_resp and len(json_resp[\"prescriptions\"]) > 0, \"No prescriptions returned on upload success\"\n        prescription = json_resp[\"prescriptions\"][0]\n        assert \"id\" in prescription, \"Uploaded prescription missing id\"\n        prescription_id = prescription[\"id\"]\n        assert \"createdAt\" not in prescription or isinstance(prescription.get(\"createdAt\", None), (str, type(None))), \"createdAt field type invalid on upload response\"\n\n        # Step 2: Create an AI extraction configuration to validate AI config creation\n        config_url = f\"{BASE_URL}/api/configs\"\n        config_payload = {\n            \"name\": \"Test Configuration\",\n            \"selectedModels\": [\"OpenAI GPT-4V\", \"Anthropic Claude\", \"Google Gemini\"],\n            \"selectedFields\": [\"patientName\", \"medication\", \"doctorName\"],\n            \"customPrompts\": {\"patientName\": \"Detect patient's full name\"},\n            \"isDefault\": False\n        }\n        config_resp = requests.post(config_url, json=config_payload, timeout=TIMEOUT)\n        assert config_resp.status_code == 201, f\"Config creation failed with status {config_resp.status_code} and text {config_resp.text}\"\n        created_config = config_resp.json()\n        assert \"id\" in created_config, \"Configuration creation response missing id\"\n\n        # If returned config has id, store it for cleanup\n        if \"id\" in created_config:\n            config_id = created_config[\"id\"]\n\n        # Step 3: Process the uploaded prescription using the AI models with the created config\n        process_url = f\"{BASE_URL}/api/prescriptions/{prescription_id}/process\"\n        process_payload = {\n            \"selectedModels\": [\"OpenAI GPT-4V\", \"Anthropic Claude\", \"Google Gemini\"],\n            \"customPrompts\": {\"patientName\": \"Detect patient's full name\"}\n        }\n        process_resp = requests.post(process_url, json=process_payload, timeout=TIMEOUT)\n        # Processing might be async or synchronous; assume synchronous success\n        assert process_resp.status_code == 200, f\"Processing failed with status {process_resp.status_code} and text {process_resp.text}\"\n\n        # Step 4: Retrieve prescription by id, expecting extraction results and createdAt field\n        get_url = f\"{BASE_URL}/api/prescriptions/{prescription_id}\"\n        get_resp = requests.get(get_url, timeout=TIMEOUT)\n        assert get_resp.status_code == 200, f\"Get prescription by id failed with status {get_resp.status_code} and text {get_resp.text}\"\n        prescription_data = get_resp.json()\n        # Check for the createdAt field existence and validity\n        assert \"createdAt\" in prescription_data, \"createdAt field missing in retrieved prescription\"\n        assert isinstance(prescription_data[\"createdAt\"], str) and len(prescription_data[\"createdAt\"]) > 0, \"createdAt field invalid or empty\"\n        # Check extraction results presence and structure\n        assert \"extractedData\" in prescription_data, \"extractedData missing in prescription response\"\n        extracted_data = prescription_data[\"extractedData\"]\n        assert isinstance(extracted_data, dict), f\"extractedData is not a dict: {extracted_data}\"\n        # It's acceptable if extractedData is empty dict if AI extraction is still being processed,\n        # but we at least check the field exists.\n\n        # Step 5: Retrieve prescription by invalid/non-existent id to confirm 404\n        invalid_id = \"invalid-id-1234abcd\"\n        invalid_resp = requests.get(f\"{BASE_URL}/api/prescriptions/{invalid_id}\", timeout=TIMEOUT)\n        assert invalid_resp.status_code == 404, f\"Expected 404 for invalid id, got {invalid_resp.status_code}\"\n\n    finally:\n        # Cleanup: Delete the uploaded prescription\n        if prescription_id:\n            del_url = f\"{BASE_URL}/api/prescriptions/{prescription_id}\"\n            try:\n                requests.delete(del_url, timeout=TIMEOUT)\n            except Exception:\n                pass\n        # Cleanup: Delete configuration if created and id is known\n        if config_id:\n            try:\n                del_config_url = f\"{BASE_URL}/api/configs/{config_id}\"\n                requests.delete(del_config_url, timeout=TIMEOUT)\n            except Exception:\n                pass\n\ntest_retrieve_prescription_by_id_with_extraction_results()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 98, in <module>\n  File \"<string>\", line 26, in test_retrieve_prescription_by_id_with_extraction_results\nAssertionError: Upload failed with status 500 and text {\"message\":\"Unexpected field\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-24T10:29:43.411Z",
    "modified": "2025-10-24T10:31:46.122Z"
  },
  {
    "projectId": "1410c8a3-78ca-4402-b7a2-8a693caa587a",
    "testId": "f9a19047-41b2-4bb9-a8bf-119226411031",
    "userId": "e468b478-00f1-70bb-e7a0-b845d2b9acfc",
    "title": "TC005-delete prescription with force parameter handling",
    "description": "Verify DELETE /api/prescriptions/{id} endpoint deletes a prescription successfully when allowed, returns 400 if force parameter is missing for completed prescriptions, and returns 404 if the prescription id does not exist.",
    "code": "import requests\nimport io\n\nBASE_URL = \"http://localhost:5000\"\nTIMEOUT = 30\n\ndef test_delete_prescription_with_force_parameter_handling():\n    # Step 1: Upload a prescription file to create a new prescription for testing\n    files = [\n        ('files', ('test_prescription.png', io.BytesIO(b\"fake image data\"), 'image/png'))\n    ]\n    created_prescription_id = None\n\n    try:\n        upload_resp = requests.post(\n            f\"{BASE_URL}/api/prescriptions/upload\",\n            files=files,\n            timeout=TIMEOUT\n        )\n        assert upload_resp.status_code == 200, f\"Upload failed: {upload_resp.text}\"\n        upload_json = upload_resp.json()\n        assert \"prescriptions\" in upload_json and len(upload_json[\"prescriptions\"]) > 0\n\n        created_prescription = upload_json[\"prescriptions\"][0]\n        created_prescription_id = created_prescription.get(\"id\")\n        assert created_prescription_id, \"Uploaded prescription has no id\"\n        assert \"createdAt\" in created_prescription, \"createdAt field missing in uploaded prescription\"\n\n        # Step 2: Try to delete non-existent prescription (expected 404)\n        fake_id = \"nonexistent-id-123456\"\n        resp_404 = requests.delete(f\"{BASE_URL}/api/prescriptions/{fake_id}\", timeout=TIMEOUT)\n        assert resp_404.status_code == 404, \"Expected 404 for non-existent prescription id\"\n\n        # Step 3: Simulate a completed prescription by processing it\n        process_body = {\n            \"selectedModels\": [\"OpenAI GPT-4V\"],\n            \"customPrompts\": {}\n        }\n        process_resp = requests.post(\n            f\"{BASE_URL}/api/prescriptions/{created_prescription_id}/process\",\n            json=process_body,\n            timeout=TIMEOUT\n        )\n        assert process_resp.status_code == 200, f\"Processing prescription failed: {process_resp.text}\"\n\n        # Step 4: Attempt to delete prescription WITHOUT force param (expect 400)\n        resp_400 = requests.delete(f\"{BASE_URL}/api/prescriptions/{created_prescription_id}\", timeout=TIMEOUT)\n        assert resp_400.status_code == 400, \"Expected 400 when deleting completed prescription without force\"\n\n        # Step 5: Delete prescription WITH force=true query parameter (expect 200)\n        resp_200 = requests.delete(\n            f\"{BASE_URL}/api/prescriptions/{created_prescription_id}?force=true\",\n            timeout=TIMEOUT\n        )\n        assert resp_200.status_code == 200, \"Expected 200 when deleting with force parameter\"\n\n        # Confirm deletion by trying to GET the deleted prescription (expect 404)\n        get_resp = requests.get(f\"{BASE_URL}/api/prescriptions/{created_prescription_id}\", timeout=TIMEOUT)\n        assert get_resp.status_code == 404, \"Deleted prescription should not be found\"\n\n    finally:\n        # Cleanup: Attempt to delete the prescription in case it wasn't deleted\n        if created_prescription_id:\n            # Delete with force parameter to ensure removal\n            try:\n                requests.delete(\n                    f\"{BASE_URL}/api/prescriptions/{created_prescription_id}?force=true\",\n                    timeout=TIMEOUT\n                )\n            except Exception:\n                pass\n\ntest_delete_prescription_with_force_parameter_handling()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 73, in <module>\n  File \"<string>\", line 20, in test_delete_prescription_with_force_parameter_handling\nAssertionError: Upload failed: {\"error\":\"No files could be processed\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-24T10:29:43.416Z",
    "modified": "2025-10-24T10:31:00.094Z"
  },
  {
    "projectId": "1410c8a3-78ca-4402-b7a2-8a693caa587a",
    "testId": "f4b001d2-f35e-48a6-8c51-30ae2eb43f64",
    "userId": "e468b478-00f1-70bb-e7a0-b845d2b9acfc",
    "title": "TC006-process prescription with selected ai models and custom prompts",
    "description": "Test POST /api/prescriptions/{id}/process endpoint to process a prescription image using selected AI models and custom prompts, ensuring parallel processing, correct handling of missing image data (400), non-existent prescription (404), and successful processing (200).",
    "code": "import requests\nimport io\nimport time\n\nBASE_URL = \"http://localhost:5000\"\nTIMEOUT = 30\nHEADERS_JSON = {\"Content-Type\": \"application/json\"}\n\ndef test_process_prescription_with_selected_ai_models_and_custom_prompts():\n    # Step 1: Upload a prescription file to create a prescription resource for testing\n    files = [\n        (\"files\", (\n            \"test_prescription.jpg\",\n            io.BytesIO(b\"\\xff\\xd8\\xff\\xe0\" + b\"0\" * 1024),  # minimal JPEG header + padding bytes\n            \"image/jpeg\",\n        ))\n    ]\n    upload_resp = requests.post(f\"{BASE_URL}/api/prescriptions/upload\", files=files, timeout=TIMEOUT)\n    assert upload_resp.status_code == 200, \"Uploading prescription file failed\"\n    upload_data = upload_resp.json()\n    assert \"prescriptions\" in upload_data and len(upload_data[\"prescriptions\"]) > 0, \"No prescriptions returned after upload\"\n    prescription = upload_data[\"prescriptions\"][0]\n    prescription_id = prescription.get(\"id\")\n    assert prescription_id, \"Uploaded prescription has no id\"\n\n    # Verify createdAt field presence in uploaded prescription\n    assert \"createdAt\" in prescription, \"createdAt field missing in uploaded prescription\"\n\n    try:\n        # Step 2: Test processing with valid payload - selectedModels and customPrompts\n        process_payload = {\n            \"selectedModels\": [\"OpenAI GPT-4V\", \"Anthropic Claude\", \"Google Gemini\"],\n            \"customPrompts\": {\n                \"OpenAI GPT-4V\": \"Extract patient name and medication details\",\n                \"Anthropic Claude\": \"Focus on dosage information\",\n                \"Google Gemini\": \"Analyze investigations and doctor notes\"\n            }\n        }\n        process_resp = requests.post(\n            f\"{BASE_URL}/api/prescriptions/{prescription_id}/process\",\n            json=process_payload,\n            headers=HEADERS_JSON,\n            timeout=TIMEOUT\n        )\n        assert process_resp.status_code == 200, \"Processing prescription failed with valid data\"\n\n        # Step 3: Test processing with non-existent prescription ID\n        fake_id = \"nonexistent-prescription-id-12345\"\n        fake_payload = {\n            \"selectedModels\": [\"OpenAI GPT-4V\"],\n            \"customPrompts\": {\"OpenAI GPT-4V\": \"Extract all details\"}\n        }\n        fake_resp = requests.post(\n            f\"{BASE_URL}/api/prescriptions/{fake_id}/process\",\n            json=fake_payload,\n            headers=HEADERS_JSON,\n            timeout=TIMEOUT\n        )\n        assert fake_resp.status_code == 404, f\"Expected 404 for non-existent prescription, got {fake_resp.status_code}\"\n\n    finally:\n        # Cleanup: Delete the created prescription\n        del_resp = requests.delete(f\"{BASE_URL}/api/prescriptions/{prescription_id}\", timeout=TIMEOUT)\n        # Could be 200 if deleted or 404 if already gone\n        assert del_resp.status_code in (200, 404), f\"Failed to delete prescription {prescription_id} after test\"\n\n\ntest_process_prescription_with_selected_ai_models_and_custom_prompts()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 68, in <module>\n  File \"<string>\", line 19, in test_process_prescription_with_selected_ai_models_and_custom_prompts\nAssertionError: Uploading prescription file failed\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-24T10:29:43.422Z",
    "modified": "2025-10-24T10:30:57.883Z"
  },
  {
    "projectId": "1410c8a3-78ca-4402-b7a2-8a693caa587a",
    "testId": "9a60bc1c-60a1-496a-80e3-75922e1a51df",
    "userId": "e468b478-00f1-70bb-e7a0-b845d2b9acfc",
    "title": "TC007-process existing prescription without file upload",
    "description": "Verify POST /api/prescriptions/{id}/process-existing endpoint processes an existing prescription without requiring file upload, returns 400 if no image data is available, 404 if prescription not found, and 200 on successful processing.",
    "code": "import requests\nimport io\n\nBASE_URL = \"http://localhost:5000\"\nTIMEOUT = 30\n\ndef test_process_existing_prescription_without_file_upload():\n    # Helper to upload a prescription file\n    def upload_prescription_file():\n        upload_url = f\"{BASE_URL}/api/prescriptions/upload\"\n        files = [\n            ('files', ('test_prescription.png', io.BytesIO(b'test image content'), 'image/png'))\n        ]\n        response = requests.post(upload_url, files=files, timeout=TIMEOUT)\n        response.raise_for_status()\n        data = response.json()\n        assert \"prescriptions\" in data and isinstance(data[\"prescriptions\"], list)\n        assert len(data[\"prescriptions\"]) > 0\n        prescription = data[\"prescriptions\"][0]\n        assert \"id\" in prescription\n        assert \"createdAt\" in prescription\n        return prescription[\"id\"]\n\n    # Helper to delete a prescription by id\n    def delete_prescription(prescription_id):\n        del_url = f\"{BASE_URL}/api/prescriptions/{prescription_id}\"\n        try:\n            response = requests.delete(del_url, timeout=TIMEOUT)\n            # It is okay if deletion returns 404 because it might already be deleted.\n            if response.status_code not in [200, 404]:\n                response.raise_for_status()\n        except requests.RequestException:\n            pass\n\n    # Upload a prescription to get a valid id with image data\n    prescription_id = None\n    try:\n        prescription_id = upload_prescription_file()\n\n        # 1. Test successful processing (200)\n        process_url = f\"{BASE_URL}/api/prescriptions/{prescription_id}/process-existing\"\n        resp = requests.post(process_url, timeout=TIMEOUT)\n        assert resp.status_code == 200, f\"Expected 200 on successful processing, got {resp.status_code}\"\n\n        # 2. Test 400 if no image data available\n        get_all_url = f\"{BASE_URL}/api/prescriptions\"\n        get_resp = requests.get(get_all_url, timeout=TIMEOUT)\n        get_resp.raise_for_status()\n        prescriptions = get_resp.json()\n        no_image_data_id = None\n        for p in prescriptions:\n            if not p.get(\"imageData\"):\n                no_image_data_id = p.get(\"id\")\n                break\n\n        if no_image_data_id:\n            resp_400 = requests.post(f\"{BASE_URL}/api/prescriptions/{no_image_data_id}/process-existing\", timeout=TIMEOUT)\n            assert resp_400.status_code == 400, f\"Expected 400 if no image data, got {resp_400.status_code}\"\n\n        # 3. Test 404 if prescription not found\n        fake_id = \"00000000-0000-0000-0000-000000000000\"\n        resp_404 = requests.post(f\"{BASE_URL}/api/prescriptions/{fake_id}/process-existing\", timeout=TIMEOUT)\n        assert resp_404.status_code == 404, f\"Expected 404 for non-existent prescription, got {resp_404.status_code}\"\n\n    finally:\n        if prescription_id:\n            # Clean up created prescription\n            delete_prescription(prescription_id)\n\ntest_process_existing_prescription_without_file_upload()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 70, in <module>\n  File \"<string>\", line 38, in test_process_existing_prescription_without_file_upload\n  File \"<string>\", line 15, in upload_prescription_file\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 400 Client Error: Bad Request for url: http://localhost:5000/api/prescriptions/upload\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-24T10:29:43.428Z",
    "modified": "2025-10-24T10:31:02.023Z"
  },
  {
    "projectId": "1410c8a3-78ca-4402-b7a2-8a693caa587a",
    "testId": "440d4415-7cdf-4255-a7de-330695db6f77",
    "userId": "e468b478-00f1-70bb-e7a0-b845d2b9acfc",
    "title": "TC008-get all extraction results with correct schema",
    "description": "Test GET /api/extraction-results endpoint to return a list of extraction results with fields including id, prescriptionId, modelName, fieldName, extractedValue, confidence, processingTime, and createdAt.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:5000\"\nEXTRACTION_RESULTS_ENDPOINT = f\"{BASE_URL}/api/extraction-results\"\nTIMEOUT = 30\n\ndef test_get_all_extraction_results_with_correct_schema():\n    try:\n        response = requests.get(EXTRACTION_RESULTS_ENDPOINT, timeout=TIMEOUT)\n        assert response.status_code == 200, f\"Expected status code 200, got {response.status_code}\"\n\n        extraction_results = response.json()\n        assert isinstance(extraction_results, list), \"Response is not a list\"\n\n        required_fields = {\n            \"id\": str,\n            \"prescriptionId\": str,\n            \"modelName\": str,\n            \"fieldName\": str,\n            \"extractedValue\": str,\n            \"confidence\": (int, float),\n            \"processingTime\": (int, float),\n            \"createdAt\": str,\n        }\n\n        for result in extraction_results:\n            assert isinstance(result, dict), \"Extraction result item is not a dict\"\n            for field, field_type in required_fields.items():\n                assert field in result, f\"Field '{field}' missing in extraction result\"\n                # Allow confidence and processingTime to be int or float\n                if isinstance(field_type, tuple):\n                    assert isinstance(result[field], field_type), f\"Field '{field}' is not of type {field_type}\"\n                else:\n                    assert isinstance(result[field], field_type), f\"Field '{field}' is not of type {field_type}\"\n\n    except requests.exceptions.RequestException as e:\n        assert False, f\"Request to {EXTRACTION_RESULTS_ENDPOINT} failed: {e}\"\n\ntest_get_all_extraction_results_with_correct_schema()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-24T10:29:43.433Z",
    "modified": "2025-10-24T10:30:36.950Z"
  },
  {
    "projectId": "1410c8a3-78ca-4402-b7a2-8a693caa587a",
    "testId": "e0e9f3b7-227e-4729-958f-6b72e7ce48aa",
    "userId": "e468b478-00f1-70bb-e7a0-b845d2b9acfc",
    "title": "TC009-manage extraction configurations crud operations",
    "description": "Verify the Configuration Management API endpoints: GET /api/configs returns all configurations, POST /api/configs creates new configurations with validation, and PUT /api/configs/{id} updates existing configurations or returns 404 if not found.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:5000\"\nHEADERS = {\"Content-Type\": \"application/json\"}\nTIMEOUT = 30\n\n\ndef test_manage_extraction_configurations_crud_operations():\n    # Helper function to create config payload\n    def create_config_payload(name_suffix=\"test\"):\n        return {\n            \"name\": f\"Config {name_suffix} {uuid.uuid4()}\",\n            \"selectedModels\": [\"OpenAI GPT-4V\", \"Anthropic Claude\"],\n            \"selectedFields\": [\"patientName\", \"medication\", \"doctorName\"],\n            \"customPrompts\": {\"patientName\": \"Extract patient full name.\"},\n            \"isDefault\": False\n        }\n\n    # 1. GET /api/configs - initial fetch all configurations\n    resp_get_initial = requests.get(f\"{BASE_URL}/api/configs\", timeout=TIMEOUT)\n    assert resp_get_initial.status_code == 200, f\"Expected 200 but got {resp_get_initial.status_code}\"\n    configs_initial = resp_get_initial.json()\n    assert isinstance(configs_initial, list), \"GET /api/configs did not return a list\"\n    # Verify createdAt field presence for each config\n    for c in configs_initial:\n        assert \"createdAt\" in c, \"Configuration missing 'createdAt' field\"\n\n    config_id = None\n    try:\n        # 2. POST /api/configs - create new configuration with valid payload\n        new_config_payload = create_config_payload()\n        resp_post = requests.post(\n            f\"{BASE_URL}/api/configs\",\n            json=new_config_payload,\n            headers=HEADERS,\n            timeout=TIMEOUT,\n        )\n        assert resp_post.status_code == 201, f\"Expected 201 on create but got {resp_post.status_code}\"\n        created_config = resp_post.json()\n        # The API might return the created config or only message - adjust assertion accordingly\n        if isinstance(created_config, dict):\n            # Should contain at least an id and createdAt in returned data\n            assert \"id\" in created_config or \"name\" in created_config, \"Created config response missing expected keys\"\n            # If id is available use it for update\n            if \"id\" in created_config:\n                config_id = created_config[\"id\"]\n            elif \"name\" in created_config:\n                # Try to refetch to get created config id\n                # fallback in case API returns created object partially\n                fetch_resp = requests.get(f\"{BASE_URL}/api/configs\", timeout=TIMEOUT)\n                configs = fetch_resp.json()\n                for conf in configs:\n                    if conf.get(\"name\") == new_config_payload[\"name\"]:\n                        config_id = conf.get(\"id\")\n                        break\n            # Check for createdAt presence\n            if \"createdAt\" in created_config:\n                assert created_config[\"createdAt\"], \"'createdAt' field is empty\"\n        else:\n            # If nothing returned, try to fetch by name if possible\n            fetch_resp = requests.get(f\"{BASE_URL}/api/configs\", timeout=TIMEOUT)\n            configs = fetch_resp.json()\n            for conf in configs:\n                if conf.get(\"name\") == new_config_payload[\"name\"]:\n                    config_id = conf.get(\"id\")\n                    break\n        assert config_id is not None, \"Created configuration id could not be determined\"\n\n        # 3. POST /api/configs - create new configuration with invalid payload (missing required fields)\n        invalid_payload = {\n            \"selectedModels\": [\"OpenAI GPT-4V\"],\n            # missing name and selectedFields\n        }\n        resp_post_invalid = requests.post(\n            f\"{BASE_URL}/api/configs\",\n            json=invalid_payload,\n            headers=HEADERS,\n            timeout=TIMEOUT,\n        )\n        assert resp_post_invalid.status_code == 400, f\"Expected 400 on invalid create but got {resp_post_invalid.status_code}\"\n\n        # 4. PUT /api/configs/{id} - update existing configuration\n        update_payload = {\n            \"name\": f\"Updated Config {uuid.uuid4()}\",\n            \"selectedModels\": [\"Google Gemini\"],\n            \"selectedFields\": [\"patientName\", \"investigations\"],\n            \"customPrompts\": {\"investigations\": \"Extract medical investigation details.\"},\n            \"isDefault\": True,\n        }\n        resp_put = requests.put(\n            f\"{BASE_URL}/api/configs/{config_id}\",\n            json=update_payload,\n            headers=HEADERS,\n            timeout=TIMEOUT,\n        )\n        assert resp_put.status_code == 200, f\"Expected 200 on update but got {resp_put.status_code}\"\n\n        # Verify update by GET /api/configs and finding updated config\n        resp_get_after_update = requests.get(f\"{BASE_URL}/api/configs\", timeout=TIMEOUT)\n        assert resp_get_after_update.status_code == 200, \"Failed to retrieve configs after update\"\n        configs_after_update = resp_get_after_update.json()\n        updated_config = None\n        for c in configs_after_update:\n            if c.get(\"id\") == config_id:\n                updated_config = c\n                break\n        assert updated_config is not None, \"Updated configuration not found in GET /api/configs\"\n        assert updated_config.get(\"name\") == update_payload[\"name\"], \"Configuration name not updated correctly\"\n        assert updated_config.get(\"isDefault\") == True, \"Configuration isDefault not updated correctly\"\n        assert \"createdAt\" in updated_config, \"Updated configuration missing 'createdAt' field\"\n\n        # 5. PUT /api/configs/{id} - update non-existent configuration, expect 404\n        non_existent_id = str(uuid.uuid4())\n        resp_put_404 = requests.put(\n            f\"{BASE_URL}/api/configs/{non_existent_id}\",\n            json=update_payload,\n            headers=HEADERS,\n            timeout=TIMEOUT,\n        )\n        assert resp_put_404.status_code == 404, f\"Expected 404 on update non-existent config but got {resp_put_404.status_code}\"\n\n    finally:\n        # Cleanup: delete the created config if possible (if API supports delete, else skip)\n        if config_id:\n            try:\n                requests.delete(f\"{BASE_URL}/api/configs/{config_id}\", timeout=TIMEOUT)\n            except Exception:\n                pass\n\n\ntest_manage_extraction_configurations_crud_operations()",
    "testStatus": "PASSED",
    "testError": "",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-24T10:29:43.443Z",
    "modified": "2025-10-24T10:30:46.883Z"
  },
  {
    "projectId": "1410c8a3-78ca-4402-b7a2-8a693caa587a",
    "testId": "9899918b-d9ca-42ec-a629-7d74dc6a180b",
    "userId": "e468b478-00f1-70bb-e7a0-b845d2b9acfc",
    "title": "TC010-export prescription data in csv and json formats",
    "description": "Test GET /api/export/csv and GET /api/export/json endpoints to export prescription data by single or multiple prescription IDs, ensuring correct file format, content type, and data accuracy in the exported files.",
    "code": "import requests\nimport io\nimport csv\nimport json\n\nBASE_URL = \"http://localhost:5000\"\nTIMEOUT = 30\n\n\ndef test_export_prescription_data_csv_json():\n    # Helper function to upload a test prescription file\n    def upload_prescription_file():\n        upload_url = f\"{BASE_URL}/api/prescriptions/upload\"\n        # Create a dummy file in memory with minimal content (simulate prescription image)\n        file_content = b\"dummy image content\"\n        # Correctly pass multiple files: list of tuples with key 'files'\n        files = [(\"files\", (\"test_prescription.png\", io.BytesIO(file_content), \"image/png\"))]\n        resp = requests.post(upload_url, files=files, timeout=TIMEOUT)\n        resp.raise_for_status()\n        data = resp.json()\n        assert \"prescriptions\" in data and isinstance(data[\"prescriptions\"], list)\n        assert len(data[\"prescriptions\"]) >= 1\n        return data[\"prescriptions\"][0][\"id\"]\n\n    # Helper function to delete a prescription by id\n    def delete_prescription(prescription_id: str):\n        delete_url = f\"{BASE_URL}/api/prescriptions/{prescription_id}\"\n        resp = requests.delete(delete_url, timeout=TIMEOUT)\n        # Accept 200 or 404 if already deleted to ensure cleanup\n        assert resp.status_code in (200, 404)\n\n    prescription_id = None\n\n    try:\n        # Step 1: Upload a prescription to obtain a valid prescription ID\n        prescription_id = upload_prescription_file()\n\n        # Step 2: Test export single prescription as CSV\n        csv_url = f\"{BASE_URL}/api/export/csv\"\n        params_single = {\"prescriptionId\": prescription_id}\n        resp_csv_single = requests.get(csv_url, params=params_single, timeout=TIMEOUT)\n        assert resp_csv_single.status_code == 200\n        content_type_csv = resp_csv_single.headers.get(\"Content-Type\", \"\")\n        assert \"text/csv\" in content_type_csv.lower() or \"application/csv\" in content_type_csv.lower()\n        # Validate CSV content is not empty and contains createdAt field in one of the rows/headers\n        csv_text = resp_csv_single.text\n        assert csv_text.strip() != \"\"\n        csv_reader = csv.reader(csv_text.splitlines())\n        rows = list(csv_reader)\n        assert len(rows) > 0\n        header = rows[0]\n        # Normalize header to lower case for checking createdAt (assuming possible case variation)\n        header_lower = [h.lower() for h in header]\n        assert any(h == \"createdat\" or h == \"created_at\" for h in header_lower)\n\n        # Step 3: Test export multiple prescriptions as CSV\n        # Upload a second prescription to test multiple export\n        prescription_id_2 = upload_prescription_file()\n        try:\n            params_multiple = {\"prescriptionIds\": f\"{prescription_id},{prescription_id_2}\"}\n            resp_csv_multiple = requests.get(csv_url, params=params_multiple, timeout=TIMEOUT)\n            assert resp_csv_multiple.status_code == 200\n            content_type_csv_multi = resp_csv_multiple.headers.get(\"Content-Type\", \"\")\n            assert \"text/csv\" in content_type_csv_multi.lower() or \"application/csv\" in content_type_csv_multi.lower()\n            csv_text_multi = resp_csv_multiple.text\n            assert csv_text_multi.strip() != \"\"\n            csv_reader_multi = csv.reader(csv_text_multi.splitlines())\n            rows_multi = list(csv_reader_multi)\n            assert len(rows_multi) > 0\n            header_multi = rows_multi[0]\n            header_lower_multi = [h.lower() for h in header_multi]\n            assert any(h == \"createdat\" or h == \"created_at\" for h in header_lower_multi)\n        finally:\n            delete_prescription(prescription_id_2)\n\n        # Step 4: Test export single prescription as JSON\n        json_url = f\"{BASE_URL}/api/export/json\"\n        resp_json_single = requests.get(json_url, params=params_single, timeout=TIMEOUT)\n        assert resp_json_single.status_code == 200\n        content_type_json = resp_json_single.headers.get(\"Content-Type\", \"\")\n        assert \"application/json\" in content_type_json.lower()\n        json_data = resp_json_single.json()\n        assert \"prescriptions\" in json_data and isinstance(json_data[\"prescriptions\"], list)\n        assert len(json_data[\"prescriptions\"]) > 0\n        # Check presence of createdAt in at least one prescription object\n        createdAt_present = any(any(k.lower() == \"createdat\" for k in pres.keys()) for pres in json_data[\"prescriptions\"])\n        assert createdAt_present\n        # Also check extractionResults and exportedAt fields exist\n        assert \"extractionResults\" in json_data and isinstance(json_data[\"extractionResults\"], list)\n        assert \"exportedAt\" in json_data and isinstance(json_data[\"exportedAt\"], str)\n\n        # Step 5: Test export multiple prescriptions as JSON\n        resp_json_multiple = requests.get(json_url, params=params_multiple, timeout=TIMEOUT)\n        assert resp_json_multiple.status_code == 200\n        content_type_json_multi = resp_json_multiple.headers.get(\"Content-Type\", \"\")\n        assert \"application/json\" in content_type_json_multi.lower()\n        json_data_multi = resp_json_multiple.json()\n        assert \"prescriptions\" in json_data_multi and isinstance(json_data_multi[\"prescriptions\"], list)\n        assert len(json_data_multi[\"prescriptions\"]) > 0\n        createdAt_multi = any(any(k.lower() == \"createdat\" for k in pres.keys()) for pres in json_data_multi[\"prescriptions\"])\n        assert createdAt_multi\n        assert \"extractionResults\" in json_data_multi and isinstance(json_data_multi[\"extractionResults\"], list)\n        assert \"exportedAt\" in json_data_multi and isinstance(json_data_multi[\"exportedAt\"], str)\n\n    finally:\n        if prescription_id:\n            delete_prescription(prescription_id)\n\n\ntest_export_prescription_data_csv_json()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 110, in <module>\n  File \"<string>\", line 36, in test_export_prescription_data_csv_json\n  File \"<string>\", line 19, in upload_prescription_file\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 400 Client Error: Bad Request for url: http://localhost:5000/api/prescriptions/upload\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-10-24T10:29:43.452Z",
    "modified": "2025-10-24T10:31:57.068Z"
  }
]
